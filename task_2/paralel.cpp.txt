#include <iostream>
#include <cstring>
#include <cmath>
#include <chrono>
#include <iomanip>
#include <stdlib.h>
#include <openacc.h>

constexpr double ANGLE1 = 10;
constexpr double ANGLE2 = 20;
constexpr double ANGLE3 = 30;
constexpr double ANGLE4 = 20;

void swap(double **&a, double **&b)
{
    double **c = a;
    a = b;
    b = c;
}

#pragma omp parellel
int main(int argc, char *argv[])
{
    int len1 = 0;
    int len2 = 0;
    int MAX_ITERATION = 0;
    double ACCURACY = 0;
    double error = 1;
    double cntIteration = 0;

    // считываем с командной строки
    for (int arg = 1; arg < argc; arg++)
    {
        if(arg == 1){
            ACCURACY = atof(argv[arg]);
        }
        if(arg == 2){
            len1 = std::stoi(argv[arg]);
            len2 = len1;
        }
        if(arg == 3){
            MAX_ITERATION = std::stoi(argv[arg]);
        }
    }

    // определяем наши шаги по рамкам
    double dt = 10 / (len1-1);
    double** arr = new double*[len1]; // работаем с данным массивом
    double** arrNew = new double* [len1]; // для записи резульата

    // init
    for (int i = 0; i < len1; i++) {
        arr[i] = new double[len2];
        arrNew[i] = new double[len2];
        for (int j = 1; j < len2-1; j++) {
            arr[i][j] = 0;
        }
    }

    // заполняем углы 1-го и 2-го массива
    arr[0][0] = ANGLE1;
    arr[0][len2 - 1] = ANGLE2;
    arr[len1 - 1][0] = ANGLE4;
    arr[len1 - 1][len2 - 1] = ANGLE3;

    arrNew[0][0] = ANGLE1;
    arrNew[0][len2 - 1] = ANGLE2;
    arrNew[len1 - 1][0] = ANGLE4;
    arrNew[len1 - 1][len2 - 1] = ANGLE3;

    // заполняем рамки матрицы
    for (int i = 1; i < len1-1; i++) {
        // лево, право, вверх, низ
        arr[i][0] = arr[i - 1][0] + dt;
        arr[i][len1 - 1] = arr[i - 1][len1 - 1] + dt;
        arr[0][i] = arr[i - 1][0] + dt;
        arr[len1 - 1][i] = arr[i - 1][len1 - 1] + dt;

        arrNew[i][0] = arr[i - 1][0] + dt;
        arrNew[i][len1 - 1] = arr[i - 1][len1 - 1] + dt;
        arrNew[0][i] = arr[i - 1][0] + dt;
        arrNew[len1 - 1][i] = arr[i - 1][len1 - 1] + dt;
    }

    #pragma acc enter data copyin(arr[len1][len2], arrNew[len1][len2])
    // производим расчет
    for (cntIteration = 1; cntIteration <= MAX_ITERATION && ACCURACY < error; cntIteration++)
    {
        error = 0;  
        #pragma acc parallel loop reduction(max:error)
        for (int i = 1; i < len1 - 1; i++) {
            #pragma acc loop reduction(max:error)
            for (int j = 1; j < len2 - 1; j++) {
                arrNew[i][j] = 0.25 * (arr[i][j + 1] + arr[i][j - 1] + arr[i - 1][j] + arr[i + 1][j]);
                error = fmax(error, fabs(arrNew[j][i] - arr[j][i]));
            }
        }
        swap(arr, arrNew);
    }
    std::cout << "ACCURACY: " << error << "\n" << "ITERATION: " << cntIteration;

    #pragma acc exit data delete(arr[len1][len2]) copyout(arrNew[len1][len2])
    for (int i = 0; i < len1; i++) { delete[] arr[i]; delete[] arrNew[i]; }
    delete[] arr;
    delete[] arrNew;
    return 0;
}
